四种模式的戳下面链接查看相关文章：

[单例模式](https://blog.csdn.net/leacock1991/article/details/111875728)、[享元模式](https://blog.csdn.net/leacock1991/article/details/112151143)

更多设计模式参看：

[设计模式之模式概述(模式汇总)(C++实现)](https://blog.csdn.net/leacock1991/article/details/111713017)



## 享元模式与单例模式区别

> **单例模式(Singleton Pattern)：** 确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式是一种对象创建型模式。

> **享元模式(Flyweight Pattern)：** 运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。



在单例模式中，一个类只能创建一个对象，而在享元模式中，一个类可以创建多个对象，每个对象被多处代码引用共享。**FlyweightFactory（享元工厂类）**可以创建多个**ConcreteFlyweight（具体享元类）**



## 享元模式与缓存的区别

在享元模式的实现中，通过工厂类来“缓存”已经创建好的对象（比如采用map存储）。这里的“缓存”实际上是“存储”的意思，跟平时所说的“数据库缓存”“CPU 缓存”“MemCache 缓存”是不同的。平时说的缓存，主要是为了**提高访问效率**，而**非复用**。



## 享元模式与对象池的区别

同样的对象池、连接池（比如数据库连接池）、线程池等也是为了复用，但其与享元模式的复用有区别的。

相对于熟悉的连接池、线程池（可参见 [ThreadPool线程池的C++实现](https://blog.csdn.net/leacock1991/article/details/109779578)），先来了解下对象池。

C++ 这样的编程语言，内存的管理是由程序员负责的。为了**避免频繁地进行对象创建和释放导致内存碎片**，可以**预先申请一片连续的内存空间**，也就是这里说的**对象池**。每次创建对象时，我们从对象池中直接取出一个空闲对象来使用，对象使用完成之后，再放回到对象池中以供后续复用，而非直接释放掉。

**池化技术**中的“复用”可以理解为“**重复使用**”，主要目的是**节省时间**（比如从对象池中取一个对象，不需要重新创建）。在任意时刻，每一个对象、连接、线程，并**不会被多处使用**，而是被一个使用者**独占**，当使用完成之后，放回到池中，再由其他使用者重复利用。

**享元模式**中的“复用”可以理解为“**共享使用**”，在整个生命周期中，都是被所有使用者共享的，主要目的是**节省空间**。



## 参考：

[https://time.geekbang.org/column/article/208572](https://time.geekbang.org/column/article/208572)



*个人能力有限，如有错误之处或者其他建议，敬请告知欢迎探讨，谢谢!*