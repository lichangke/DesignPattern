# 介绍

按实际业务场景划分，工厂模式有 3 种不同的实现方式，分别是`简单工厂模式`、`工厂方法模式`和`抽象工厂模式`。

把被创建的对象称为“产品”，把创建产品的对象称为“工厂”。如果要创建的产品不多，只要一个工厂类就可以完成，这种模式叫**简单工厂模式**。

在简单工厂模式中创建实例的方法通常为静态（static）方法，因此**简单工厂模式（Simple Factory Pattern）又叫作静态工厂方法模式（Static Factory Method Pattern）。**

`工厂方法模式`是对简单工厂模式的进一步抽象化，其好处是可以使系统在不修改原来代码的情况下引进新的产品，即满足开闭原则。



# 简单工厂模式

## 意图：

定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。

## 解决问题：

主要解决接口选择的问题。

## 实现概述：

创建过程在其子类执行。让其子类实现工厂接口，返回的也是一个抽象的产品。

## 应用场景：

明确地计划不同条件下创建不同实例。对于产品种类相对较少的情况，考虑使用简单工厂模式。使用简单工厂模式的客户端只需要传入工厂类的参数，不需要关心如何创建对象的逻辑，可以很方便地创建所需产品。

## 优点：

1. 工厂类包含必要的逻辑判断，可以决定在什么时候创建哪一个产品的实例。
2. 客户端无需知道所创建具体产品的类名，只需知道参数即可。

## 缺点：

1. 简单工厂模式的工厂类单一，负责所有产品的创建，职责过重，一旦异常，整个系统将受影响。且工厂类代码会非常臃肿，违背高聚合原则。
2. 系统扩展困难，一旦增加新产品不得不修改工厂逻辑，在产品类型较多时，可能造成逻辑过于复杂
3. 简单工厂模式使用了 static 工厂方法，造成工厂角色无法形成基于继承的等级结构。

## 模式结构

- 抽象产品（Product）：是简单工厂创建的所有对象的父类，负责描述所有实例共有的公共接口。
- 具体产品（ConcreteProduct）：抽象产品的派生类，包含具体产品特有的实现方法，是简单工厂模式的创建目标。
- 简单工厂（SimpleFactory）：根据客户提供的具体产品参数，创建具体产品实例

![01_工厂模式](\upload\01_工厂模式\01_简单工厂.jpg)



```cpp
//抽象产品类
class AbstractProduct
{
public:
	//抽象方法：
};
 
//具体产品类
class ConcreteProduct :public AbstractProduct
{
public:
	//具体实现方法
};
 
class SimpleFactory
{
public:
	AbstractProduct createProduct(string productName)
	{
		AbstractProduct pro = NULL;
		if (productName == "ProductA"){
			pro = new ProductA();
		}
		else if (productName == "ProductB"){
			pro = new ProductB();
		}
		...
	}
};
```



## 代码示例

工厂生产不同的球类。

### GitHub

[**SimpleFactory**](https://github.com/lichangke/DesignPattern/tree/main/demos/01_%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/SimpleFactory)

### 定义抽象产品类

```cpp
///定义抽象产品类
class AbstractBallProduct
{
public:
    ~AbstractBallProduct() = default;
    //抽象方法：
    virtual void productName() = 0;
    virtual void productIntroduction() = 0;
protected:
    AbstractBallProduct()= default;

};
```

### 定义具体产品类

```cpp

//三个具体产品类
//具体产品类Basketball
class Basketball :public AbstractBallProduct
{
public:
    Basketball() = default;
    ~Basketball() {
        std::cout << "Basketball Bye" << std::endl;
    };
    void productName() override{
        std::cout << "This is a Basketball" << std::endl;
    }
    void productIntroduction() override{
        std::cout << "Introduction for Basketball" << std::endl;
    }
};

//具体产品类Football
class Football :public AbstractBallProduct
{
public:
    Football() = default;
    ~Football() {
        std::cout << "Football Bye" << std::endl;
    };
    void productName() override{
        std::cout << "This is a Football" << std::endl;
    }
    void productIntroduction() override{
        std::cout << "Introduction for Football" << std::endl;
    }
};

//具体产品类Volleyball
class Volleyball :public AbstractBallProduct
{
public:
    Volleyball() = default;
    ~Volleyball() {
        std::cout << "Volleyball Bye" << std::endl;
    };
    void productName() override{
        std::cout << "This is a Volleyball" << std::endl;
    }
    void productIntroduction() override{
        std::cout << "Introduction for Volleyball" << std::endl;
    }
};
```

### 定义工厂类

```cpp
/// 定义工厂类和工厂方法
class SimpleFactory
{
public:
    static AbstractBallProduct *getProduct(const std::string& productName)
    {
        AbstractBallProduct *pro = nullptr;
        if (productName == "Basketball"){
            pro = new Basketball();
        }
        else if (productName == "Football"){
            pro = new Football();
        }
        else if (productName == "Volleyball"){
            pro = new Volleyball();
        }
        return pro;
    }
};
```

### 测试

```cpp
#include "SimpleFactory.h"

int main() {
    std::cout << "简单工厂模式" << std::endl;
    //定义工厂类对象
    AbstractBallProduct *product = nullptr;
    product = SimpleFactory::getProduct("Basketball");
    product->productName();
    product = SimpleFactory::getProduct("Football");
    product->productIntroduction();
    product = SimpleFactory::getProduct("Volleyball");
    product->productIntroduction();
    getchar();
    return 0;
}
```

### 输出

![image-20201224165935326](\upload\01_工厂模式\A_01_工厂模式.png)

# 工厂方法模式

SimpleFactory类中有一组 if 分支判断逻辑，是不是应该用多态或其他设计模式来替代呢？实际上，如果 if 分支并不是很多，代码中有 if 分支也是完全可以接受的。应用多态或设计模式来替代 if 分支判断逻辑，也并不是没有任何缺点的，它虽然提高了代码的扩展性，更加符合开闭原则，但也增加了类的个数，牺牲了代码的可读性。

如果我们非得要将 if 分支逻辑去掉，那该怎么办呢？比较经典处理方法就是利用多态。在SimpleFactory之上再抽象一层。

`工厂方法模式`是对简单工厂模式的进一步抽象化，其好处是可以使系统在不修改原来代码的情况下引进新的产品，即满足开闭原则。



## 优点：

- 用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程。
- 灵活性增强，对于新产品的创建，只需多写一个相应的工厂类。
- 典型的解耦框架。高层模块只需要知道产品的抽象类，无须关心其他实现类，满足迪米特法则、依赖倒置原则和里氏替换原则。

## 缺点：

- 类的个数容易过多，增加复杂度
- 增加了系统的抽象性和理解难度
- 抽象产品只能生产一种产品，此弊端可使用抽象工厂模式解决。

## 模式结构

- 抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法 newProduct() 来创建产品。
- 具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。
- 抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。
- 具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。

![01_工厂方法](\upload\01_工厂模式\01_工厂方法.jpg)



## 代码示例

### GitHub

[**FactoryMethod**](https://github.com/lichangke/DesignPattern/tree/main/demos/01_%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/FactoryMethod)

### 定义抽象产品类

同上

### 定义具体产品类

同上

### 定义抽象工厂类

```cpp
/// 定义抽象工厂类
class AbstractFactory
{
public:
    ~AbstractFactory() = default;
    virtual AbstractBallProduct * getProduct() = 0;
protected:
    AbstractFactory() = default;
};
```



### 定义具体工厂类

```cpp

///三个具体工厂类
///具体工厂类  只生产单一产品
class BasketballFactory : public AbstractFactory
{
public:
    BasketballFactory() = default;
    ~BasketballFactory() = default;
    AbstractBallProduct *getProduct() override{
        return  new Basketball();
    }
};

///具体工厂类  只生产单一产品
class FootballFactory : public AbstractFactory
{
public:
    FootballFactory() = default;
    ~FootballFactory() = default;
    AbstractBallProduct *getProduct() override{
        return  new Football();
    }
};
///具体工厂类  只生产单一产品
class VolleyballFactory : public AbstractFactory
{
public:
    VolleyballFactory() = default;
    ~VolleyballFactory() = default;
    AbstractBallProduct *getProduct() override{
        return  new Volleyball();
    }
};
```

### 测试

```cpp
int main() {

    std::cout << "工厂方法模式" << std::endl;
    //定义工厂类对象和产品类对象
    AbstractBallProduct *product = nullptr;
    AbstractFactory *factory = nullptr;

    factory = new BasketballFactory();
    product = factory->getProduct();
    product->productName();

    factory = new FootballFactory();
    product = factory->getProduct();
    product->productIntroduction();

    factory = new VolleyballFactory();
    product = factory->getProduct();
    product->productIntroduction();

    getchar();
    return 0;
}
```

### 输出

![image-20201224174952734](\upload\01_工厂模式\B_01_工厂模式.png)



*个人能力有限，如有错误之处或者其他建议，敬请告知欢迎探讨，谢谢!*

