四种模式的戳下面链接查看相关文章：

[代理模式](https://blog.csdn.net/leacock1991/article/details/112156920) 、[桥接模式](https://blog.csdn.net/leacock1991/article/details/111998683)、[装饰模式](https://blog.csdn.net/leacock1991/article/details/112056643) 、[适配器模式](https://blog.csdn.net/leacock1991/article/details/111938387)

更多设计模式参看：

[设计模式之模式概述(模式汇总)(C++实现)](https://blog.csdn.net/leacock1991/article/details/111713017)

代理、桥接、装饰器、适配器，这 4 种模式是比较常用的结构型设计模式。它们的代码结构非常相似。笼统来说，它们都可以称为 Wrapper 模式，也就是通过 Wrapper 类二次封装原始类。

## 模式结构与角色：

先看看 4 种模式各自的结构与角色。

### 代理模式：

- **Subject（抽象主题角色）**：声明了真实主题和代理主题的共同接口，这样一来在任何使用真实主题的地方都可以使用代理主题，客户端通常需要针对抽象主题角色进行编程。
- **Proxy（代理主题角色）**：代理主题角色通过关联关系引用真实主题角色，因此可以控制和操纵真实主题对象；代理主题角色中提供一个与真实主题角色相同的接口（以在需要时代替真实主题角色），同时还可以在调用对真实主题对象的操作之前或之后增加新的服务和功能；
- **RealSubject（真实主题角色）**：定义了代理角色所代表的真实对象，在真实主题角色中实现了真实的业务操作，客户端可以通过代理主题角色间接调用真实主题角色中定义的操作。

Wrapper 类是Proxy

![设计模式之代理模式](\upload\代理、桥接、装饰器、适配器 4 种设计模式的区别\设计模式之代理模式.jpg)

### 桥接模式：

- **Abstraction（抽象类） ：** 用于定义抽象类的接口，它一般是抽象类，定义了一个Implementor（实现类接口）类型的对象，与其之间具有关联关系，从而分离抽象接口与实现部分
- **RefinedAbstraction（扩充抽象类）：** 扩充由Abstraction定义的接口，通常情况下它是具体类，实现Abstraction的抽象业务方法，并可以调用在Implementor中定义的业务方法。
- **Implementor（实现类接口）:** 定义实现类的接口，Implementor接口声明了一些基本操作，而具体实现交给其子类。通过关联关系，在Abstraction中不仅拥有自己的方法，还可以调用到Implementor中定义的方法，使用关联关系来替代继承关系。
- **ConcreteImplementor（具体实现类）：** 具体实现Implementor接口，在不同的ConcreteImplementor中提供基本操作的不同实现。

Wrapper 类是RefinedAbstraction

![设计模式之桥接模式](\upload\代理、桥接、装饰器、适配器 4 种设计模式的区别\设计模式之桥接模式.jpg)



### 装饰模式：

- **Component（抽象构件）：** 它是**具体构件**和**抽象装饰类**的**共同父类**，声明了在具体构件中实现的业务方法，使客户端能够以一致的方式处理未被装饰的对象以及装饰之后的对象。
- **ConcreteComponent（具体构件）：** 它是**抽象构件类的子类**，实现了在抽象构件中声明的方法，装饰器就是为它增加额外的功能（方法）。
- **Decorator（抽象装饰类）：** 它也是**抽象构件类的子类**，用于给具体构件增加功能，但是具体功能在它的子类中实现。它维护一个**指向抽象构件对象的引用**，通过该引用可以调用构件对象的方法，并通过其子类(**具体装饰类**)扩展该方法，以达到装饰的目的。
- **ConcreteDecorator（具体装饰类）：** 它是**抽象装饰类的子类**，负责向构件添加新的功能。每一个具体装饰类都定义了一些新的行为，它可以调用在抽象装饰类中定义的方法，并可以增加新的方法用以扩充对象的行为。

Wrapper 类是Decorator

![设计模式之装饰器模式](\upload\代理、桥接、装饰器、适配器 4 种设计模式的区别\设计模式之装饰器模式.jpg)



### 适配器模式：

- **Target（目标抽象类）：** 目标抽象类定义客户所需接口，可以是一个抽象类或接口，也可以是具体类。
- **Adapter（适配器类）：** **适配器类是适配器模式的核心**，可以调用另一个接口，作为一个转换器，对Adaptee和Target进行适配。
- **Adaptee（适配者类）：** 适配者即被适配的角色，它定义了一个已经存在的接口，这个接口需要适配，适配者类一般是一个具体类，包含了客户希望使用的业务方法，在某些情况下可能没有适配者类的源代码只有接口。

Wrapper 类是Adapter

**类适配器：**

![设计模式之适配器模式_类适配器](\upload\代理、桥接、装饰器、适配器 4 种设计模式的区别\设计模式之适配器模式_类适配器.jpg)



**对象适配器：**

![设计模式之适配器模式_对象适配器](\upload\代理、桥接、装饰器、适配器 4 种设计模式的区别\设计模式之适配器模式_对象适配器.jpg)

## 模式定义与意图：

再瞧瞧 4 种模式各自的定义与意图

### 代理模式

**代理模式：** 给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。其核心是代理类。一般都是采用代理类继承原始类，然后通过关联关系扩展附加功能。

### 桥接模式

**第一种理解：**

《设计模式》一书中对桥接模式的定义：

> Decouple an abstraction from its implementation so that the two can vary independently。

> 翻译成中文就是：“将抽象和实现解耦，让它们可以独立变化。

定义中的“**抽象**”，指的并**非“抽象类”或“接口”**，而是被抽象出来的一套**“类库”**，它只包含骨架代码，真正的业务逻辑需要委派给定义中的**“实现”**来完成。而定义中的“实现”，也并**非“接口的实现类”**，而是一套独立的“类库”。“抽象”和“实现”独立开发，通过对象之间的**组合关系**，组装在一起。

**第二种理解：**

>一个类存在两个（或多个）独立变化的维度，我们通过组合的方式，让这两个（或多个）维度可以独立进行扩展。通过组合关系来替代继承关系，避免继承层次的指数级爆炸。

将两个或多个独立变化的维度设计为两个或多个独立的继承等级结构，并且在**抽象层**建立一个或多个抽象关联

### 装饰模式

**装饰模式(Decorator Pattern)：** 动态地给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式比生成子类实现更为灵活。装饰模式是一种对象结构型模式。

核心在于**抽象装饰类**的设计，抽象装饰类(装饰器类)和原始类继承同样的父类，这样可以对原始类“嵌套”多个装饰器类。

### 适配器模式

**适配器模式(Adapter Pattern)：** 将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。

适配器模式有两种实现方式：**类适配器和对象适配器**。其中，**类适配器使用继承关系来实现，对象适配器使用组合关系来实现**。



## 模式区别：



### 代理模式：

代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能，这是它跟装饰器模式最大的不同。主要增强的是**非主干或者说非业务性**的功能



### 桥接模式：

桥接模式的目的是将接口部分和实现部分分离，从而让它们可以较为容易、也相对独立地加以改变。主要是**分离接口部分和实现部分**，应对**两个（或多个）独立变化**的维度



### 装饰模式：

装饰模式在不改变原始类接口的情况下，对**原始类功能进行增强**，并且支持多个装饰器的嵌套使用。主要是对**原始类功能进行增强**，支持多个装饰器的嵌套使用

### 适配器模式：

适配器模式是一种事后的补救策略，用来补救设计上的缺陷（比如接口不兼容）。适配器提供跟**原始类不同的接口**，而代理模式、装饰器模式提供的都是跟**原始类相同的接口**。主要提供跟**原始类不同的接口**。







