# 介绍

所谓“享元”，顾名思义就是被共享的单元。享元模式的意图是复用对象，节省内存，前提是享元对象是**不可变对象**。

“不可变对象”指的是，一旦通过构造函数初始化完成之后，它的状态（对象的成员变量或者属性）就不会再被修改了。

## 意图：

## 解决问题：



## 实现概述：

通过工厂模式，在工厂类中，通过一个 Map 来缓存已经创建过的享元对象，来达到复用的目的。

## 要点：

用 Map 存储对象

## 应用场景：

当一个系统中存在大量重复对象的时候，如果这些重复的对象是不可变对象，我们就可以利用享元模式将对象设计成享元，在内存中只保留一份实例，供多处代码引用。不仅仅相同对象可以设计成享元，对于相似对象，我们也可以将这些对象中相同的部分（字段）提取出来，设计成享元，让这些大量相似对象引用这些享元。

### 生活中场景

### 软件中场景

## 优点：

## 缺点：



# 享元模式 vs 单例、缓存、对象池

## 享元模式跟单例的区别

在单例模式中，一个类只能创建一个对象，而在享元模式中，一个类可以创建多个对象，每个对象被多处代码引用共享。

尽管从代码实现上来看，享元模式和多例有很多相似之处，但从设计意图上来看，它们是完全不同的。应用**享元模式**是为了**对象复用，节省内存**，而应用**多例模式**是为了**限制对象的个数**。



## 享元模式跟缓存的区别

在享元模式的实现中，通过工厂类来“缓存”已经创建好的对象。这里的“缓存”实际上是“存储”的意思，跟我们平时所说的“数据库缓存”“CPU 缓存”“MemCache 缓存”是两回事。我们平时所讲的缓存，主要是为了提高访问效率，而非复用。



## 享元模式跟对象池的区别



# 模式结构



# 代码示例

## GitHub

## 测试

## 输出



*个人能力有限，如有错误之处或者其他建议，敬请告知欢迎探讨，谢谢!*

